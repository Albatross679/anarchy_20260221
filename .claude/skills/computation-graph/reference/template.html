<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computation Graph</title>
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #ffffff;
            color: #333;
            overflow: hidden;
        }
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: calc(100% - 320px);
            height: 100%;
            overflow: hidden;
            cursor: grab;
        }
        #container:active { cursor: grabbing; }
        #graph {
            transform-origin: 0 0;
        }
        .node {
            position: absolute;
            border-radius: 12px;
            cursor: move;
            user-select: none;
            width: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: box-shadow 0.15s;
            display: flex;
            flex-direction: row;
        }
        .node-side-label {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 4px;
            font-weight: 700;
            font-size: 12px;
            letter-spacing: 3px;
            background: rgba(0,0,0,0.2);
            border-radius: 12px 0 0 12px;
            min-height: 60px;
        }
        .node-main {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        .node.has-side-label .node-header {
            border-radius: 0 12px 0 0;
        }
        .node.has-side-label .node-body {
            border-radius: 0 0 12px 0;
        }
        .node:hover { box-shadow: 0 6px 20px rgba(0,0,0,0.4); }
        .node.selected { box-shadow: 0 0 0 3px #ff5252, 0 6px 20px rgba(0,0,0,0.4); }
        /* Resize handles */
        .resize-handle {
            position: absolute;
            background: #2196F3;
            opacity: 0;
            transition: opacity 0.15s;
            z-index: 10;
        }
        .node:hover .resize-handle,
        .node.selected .resize-handle {
            opacity: 1;
        }
        .resize-e {
            right: 0;
            top: 20%;
            width: 6px;
            height: 60%;
            cursor: ew-resize;
            border-radius: 3px;
        }
        .resize-s {
            bottom: 0;
            left: 20%;
            width: 60%;
            height: 6px;
            cursor: ns-resize;
            border-radius: 3px;
        }
        .resize-se {
            right: 0;
            bottom: 0;
            width: 12px;
            height: 12px;
            cursor: nwse-resize;
            border-radius: 0 0 12px 0;
        }
        .node-header {
            padding: 8px 12px;
            font-weight: 600;
            font-size: 14px;
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            white-space: nowrap;
            border-radius: 12px 12px 0 0;
        }
        .node-body {
            padding: 10px 12px;
            font-size: 12px;
            text-align: left;
            line-height: 1.5;
            background: rgba(0,0,0,0.15);
            border-radius: 0 0 12px 12px;
        }
        .node-section {
            margin-bottom: 6px;
        }
        .node-section:last-child {
            margin-bottom: 0;
        }
        .node-section-label {
            font-weight: 600;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            opacity: 0.7;
            margin-bottom: 1px;
        }
        .node-section-content {
            font-size: 12px;
            white-space: nowrap;
        }
        .node-formula {
            background: rgba(255,255,255,0.1);
            padding: 4px 8px;
            border-radius: 6px;
            margin-top: 3px;
            text-align: center;
            white-space: nowrap;
        }
        #sidebar {
            position: fixed;
            right: 0;
            top: 0;
            width: 320px;
            height: 100%;
            background: #f5f5f5;
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #ddd;
        }
        h2 { font-size: 18px; margin-bottom: 16px; color: #333; }
        h3 { font-size: 14px; margin: 16px 0 8px; color: #666; }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
        }
        .info-panel {
            background: #fff;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 13px;
            border: 1px solid #ddd;
        }
        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
        }
        .info-label { color: #666; }
        .info-value { color: #333; font-family: monospace; }
        .controls {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }
        button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            flex: 1;
        }
        button:hover { background: #1976D2; }
        .zoom-controls {
            display: flex;
            gap: 4px;
            margin-top: 12px;
        }
        .zoom-btn {
            width: 36px;
            height: 36px;
            font-size: 20px;
            padding: 0;
            flex: none;
        }
        #selection-rect {
            position: absolute;
            border: 2px dashed #2196F3;
            background: rgba(33, 150, 243, 0.1);
            pointer-events: none;
            display: none;
        }
        svg {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            overflow: visible;
        }
        .edge {
            fill: none;
            stroke: #666;
            stroke-width: 3;
        }
        .edge-arrow {
            fill: #666;
        }
        .instructions {
            font-size: 12px;
            color: #666;
            margin-top: 16px;
            line-height: 1.6;
        }
        .instructions li { margin: 4px 0; }
        .description {
            font-size: 12px;
            color: #555;
            margin-top: 16px;
            line-height: 1.6;
            background: #fff;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="graph">
            <svg id="edges-svg" width="3000" height="3000"></svg>
            <div id="nodes-container"></div>
            <div id="selection-rect"></div>
        </div>
    </div>

    <div id="sidebar">
        <h2>Graph Title</h2>
        <p style="font-size: 12px; color: #666; margin-bottom: 12px;">
            Description of the computation graph.
        </p>

        <h3>Legend</h3>
        <!-- Legend items generated from node colors -->
        <div class="legend-item">
            <div class="legend-color" style="background: #2196F3;"></div>
            <span>Input / Output</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4CAF50;"></div>
            <span>Embedding Layer</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #E91E63;"></div>
            <span>Self-Attention</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #00BCD4;"></div>
            <span>Layer Normalization</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FF9800;"></div>
            <span>Feed-Forward Network</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #9C27B0;"></div>
            <span>Linear Projection</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #607D8B;"></div>
            <span>Residual Connection</span>
        </div>

        <h3>Selection Info</h3>
        <div class="info-panel" id="selection-info">
            <div class="info-row">
                <span class="info-label">Selected:</span>
                <span class="info-value" id="selected-count">0 nodes</span>
            </div>
        </div>

        <div class="controls">
            <button onclick="saveGraph()">Save</button>
            <button onclick="exportPositions()">Export JSON</button>
        </div>

        <div class="zoom-controls">
            <button class="zoom-btn" onclick="zoomIn()">+</button>
            <button class="zoom-btn" onclick="zoomOut()">-</button>
            <button class="zoom-btn" onclick="resetView()">R</button>
        </div>

        <p id="save-warning" style="font-size: 11px; color: #f44336; margin-top: 8px; display: none;">
            Save dialog not supported. File will be downloaded instead.
        </p>

        <ul class="instructions">
            <li>Scroll to pan the view</li>
            <li>Drag nodes to reposition</li>
            <li>Drag edges/corners to resize</li>
            <li>Shift+Click to multi-select</li>
            <li>Ctrl+A to select all</li>
            <li>Arrow keys to nudge selected</li>
        </ul>

        <div class="description">
            Architecture description here.
        </div>
    </div>

    <script>
        // === NODE DATA ===
        // Each node has: id, type, formula (optional), color, x, y, width, height, sideLabel (optional), sections (optional)
        const nodesData = [
            {
                "id": "input",
                "type": "Input",
                "formula": "X \\in \\mathbb{R}^{B \\times T}",
                "color": "#2196F3",
                "x": 100,
                "y": 50,
                "width": null,
                "height": null
            },
            {
                "id": "output",
                "type": "Output",
                "formula": "Y \\in \\mathbb{R}^{B \\times T \\times V}",
                "color": "#2196F3",
                "x": 100,
                "y": 400,
                "width": null,
                "height": null
            }
        ];

        // === EDGE DATA ===
        // Each edge has: source, target, style (vertical_down, vertical_up, horizontal_right, horizontal_left, skip_right, skip_left)
        const edgesData = [
            {
                "source": "input",
                "target": "output",
                "style": "vertical_down"
            }
        ];

        // === CONFIGURATION ===
        const MIN_NODE_WIDTH = 100;
        const MIN_NODE_HEIGHT = 80;

        const container = document.getElementById('container');
        const graph = document.getElementById('graph');
        const nodesContainer = document.getElementById('nodes-container');
        const edgesSvg = document.getElementById('edges-svg');
        const selectionRect = document.getElementById('selection-rect');

        const nodeById = {};
        nodesData.forEach(n => nodeById[n.id] = n);

        // State
        let scale = 1;
        let panX = 250;
        let panY = 30;
        let isDragging = false;
        let draggedNode = null;
        let dragStartX, dragStartY;
        let selectedNodes = new Set();
        let isSelecting = false;
        let selectStartX, selectStartY;
        let isResizing = false;
        let resizeNode = null;
        let resizeHandle = null;
        let resizeStartX, resizeStartY;
        let resizeStartWidth, resizeStartHeight;

        function updateTransform() {
            graph.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        }

        function zoomIn() {
            scale = Math.min(scale * 1.2, 5);
            updateTransform();
        }

        function zoomOut() {
            scale = Math.max(scale * 0.8, 0.1);
            updateTransform();
        }

        function resetView() {
            scale = 1;
            panX = 250;
            panY = 30;
            updateTransform();
        }

        function createNodeHTML(node) {
            let html = '';
            if (node.sideLabel) {
                html += `<div class="node-side-label">${node.sideLabel}</div>`;
            }
            html += '<div class="node-main">';
            html += `<div class="node-header">${node.type}</div>`;
            html += '<div class="node-body">';
            if (node.sections) {
                node.sections.forEach(sec => {
                    html += `<div class="node-section">`;
                    html += `<div class="node-section-label">${sec.label}</div>`;
                    html += `<div class="node-section-content">${sec.content}</div>`;
                    html += `</div>`;
                });
            }
            if (node.formula) {
                html += `<div class="node-formula">$${node.formula}$</div>`;
            }
            html += '</div></div>';
            html += `<div class="resize-handle resize-e"></div>`;
            html += `<div class="resize-handle resize-s"></div>`;
            html += `<div class="resize-handle resize-se"></div>`;
            return html;
        }

        nodesData.forEach(node => {
            const div = document.createElement('div');
            div.className = 'node';
            div.id = 'node-' + node.id;
            div.style.background = node.color;
            div.style.left = node.x + 'px';
            div.style.top = node.y + 'px';
            if (node.width) div.style.width = node.width + 'px';
            if (node.height) div.style.height = node.height + 'px';
            if (node.sideLabel) div.classList.add('has-side-label');
            div.innerHTML = createNodeHTML(node);
            nodesContainer.appendChild(div);
        });

        // Initialize KaTeX
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false}
                    ]
                });
            }
            updateTransform();
            drawEdges();
        });

        // Simplified edge drawing (implement full version based on needs)
        function drawEdges() {
            edgesSvg.innerHTML = '';

            // Create arrow marker
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead');
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '7');
            marker.setAttribute('refX', '9');
            marker.setAttribute('refY', '3.5');
            marker.setAttribute('orient', 'auto');
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
            polygon.setAttribute('fill', '#666');
            marker.appendChild(polygon);
            defs.appendChild(marker);
            edgesSvg.appendChild(defs);

            edgesData.forEach(edge => {
                const sourceEl = document.getElementById('node-' + edge.source);
                const targetEl = document.getElementById('node-' + edge.target);
                if (!sourceEl || !targetEl) return;

                const sourceNode = nodeById[edge.source];
                const targetNode = nodeById[edge.target];

                // Simple center-to-center connection
                const sx = sourceNode.x + sourceEl.offsetWidth / 2;
                const sy = sourceNode.y + sourceEl.offsetHeight;
                const tx = targetNode.x + targetEl.offsetWidth / 2;
                const ty = targetNode.y;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${sx} ${sy} L ${tx} ${ty}`);
                path.setAttribute('class', 'edge');
                path.setAttribute('marker-end', 'url(#arrowhead)');
                edgesSvg.appendChild(path);
            });
        }

        // Event handlers for dragging and selection (simplified)
        container.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('node') || e.target.closest('.node')) {
                const nodeEl = e.target.closest('.node');
                const nodeId = nodeEl.id.replace('node-', '');

                if (e.target.classList.contains('resize-handle')) {
                    isResizing = true;
                    resizeNode = nodeById[nodeId];
                    resizeHandle = e.target.classList.contains('resize-e') ? 'e' :
                                   e.target.classList.contains('resize-s') ? 's' : 'se';
                    resizeStartX = e.clientX;
                    resizeStartY = e.clientY;
                    resizeStartWidth = nodeEl.offsetWidth;
                    resizeStartHeight = nodeEl.offsetHeight;
                } else {
                    isDragging = true;
                    draggedNode = nodeById[nodeId];
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;

                    if (!e.shiftKey && !selectedNodes.has(nodeId)) {
                        selectedNodes.clear();
                        document.querySelectorAll('.node.selected').forEach(n => n.classList.remove('selected'));
                    }
                    selectedNodes.add(nodeId);
                    nodeEl.classList.add('selected');
                    updateSelectionInfo();
                }
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging && draggedNode) {
                const dx = (e.clientX - dragStartX) / scale;
                const dy = (e.clientY - dragStartY) / scale;

                selectedNodes.forEach(id => {
                    const node = nodeById[id];
                    node.x += dx;
                    node.y += dy;
                    const el = document.getElementById('node-' + id);
                    el.style.left = node.x + 'px';
                    el.style.top = node.y + 'px';
                });

                dragStartX = e.clientX;
                dragStartY = e.clientY;
                drawEdges();
            }

            if (isResizing && resizeNode) {
                const dx = (e.clientX - resizeStartX) / scale;
                const dy = (e.clientY - resizeStartY) / scale;
                const el = document.getElementById('node-' + resizeNode.id);

                if (resizeHandle === 'e' || resizeHandle === 'se') {
                    const newWidth = Math.max(MIN_NODE_WIDTH, resizeStartWidth + dx);
                    el.style.width = newWidth + 'px';
                    resizeNode.width = newWidth;
                }
                if (resizeHandle === 's' || resizeHandle === 'se') {
                    const newHeight = Math.max(MIN_NODE_HEIGHT, resizeStartHeight + dy);
                    el.style.height = newHeight + 'px';
                    resizeNode.height = newHeight;
                }
                drawEdges();
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            draggedNode = null;
            isResizing = false;
            resizeNode = null;
        });

        // Pan with scroll
        container.addEventListener('wheel', (e) => {
            e.preventDefault();
            panX -= e.deltaX;
            panY -= e.deltaY;
            updateTransform();
        });

        function updateSelectionInfo() {
            document.getElementById('selected-count').textContent = selectedNodes.size + ' nodes';
        }

        // Save functionality
        function saveGraph() {
            nodesData.forEach(n => {
                n.x = Math.round(n.x);
                n.y = Math.round(n.y);
            });

            const nodesStr = JSON.stringify(nodesData, null, 2);
            const edgesStr = JSON.stringify(edgesData, null, 2);

            let html = document.documentElement.outerHTML;
            html = html.replace(/const nodesData = \[[\s\S]*?\];/, `const nodesData = ${nodesStr};`);
            html = html.replace(/const edgesData = \[[\s\S]*?\];/, `const edgesData = ${edgesStr};`);
            html = '<!DOCTYPE html>\n<html lang="en">\n' + html.slice(html.indexOf('<head>'));

            const blob = new Blob([html], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'computation_graph.html';
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportPositions() {
            const positions = {};
            nodesData.forEach(n => {
                positions[n.id] = {
                    x: Math.round(n.x),
                    y: Math.round(n.y),
                    width: n.width || null,
                    height: n.height || null
                };
            });
            console.log(JSON.stringify(positions, null, 2));
            alert('Positions exported to console');
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'a') {
                e.preventDefault();
                nodesData.forEach(n => {
                    selectedNodes.add(n.id);
                    document.getElementById('node-' + n.id).classList.add('selected');
                });
                updateSelectionInfo();
            }

            const nudge = e.shiftKey ? 10 : 1;
            if (selectedNodes.size > 0) {
                let dx = 0, dy = 0;
                if (e.key === 'ArrowLeft') dx = -nudge;
                if (e.key === 'ArrowRight') dx = nudge;
                if (e.key === 'ArrowUp') dy = -nudge;
                if (e.key === 'ArrowDown') dy = nudge;

                if (dx || dy) {
                    e.preventDefault();
                    selectedNodes.forEach(id => {
                        const node = nodeById[id];
                        node.x += dx;
                        node.y += dy;
                        const el = document.getElementById('node-' + id);
                        el.style.left = node.x + 'px';
                        el.style.top = node.y + 'px';
                    });
                    drawEdges();
                }
            }
        });
    </script>
</body>
</html>
